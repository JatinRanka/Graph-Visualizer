{"version":3,"sources":["logo.svg","PathfindingVisualizer/Node.jsx","Algorithms/BfsAlgorithm.jsx","Algorithms/DfsAlgorithm.jsx","mazeAlgorithms/RecursiveDivision.jsx","mazeAlgorithms/CreateBorderWall.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","mazeAlgorithms/RandomMaze.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","col","key","row","isStart","isFinish","isVisited","isWall","isPath","className","id","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","React","Component","getNeighbourNodes","nodes","currentNode","TOTAL_ROWS","TOTAL_COLS","neighbourNodes","push","DfsAlgorithm","startNode","finishNode","isPathFound","pathNodes","visitedNodesAndIsPathFound","DfsUtil","visitedNodes","pop","RecursiveDivision","parameters","startRow","startCol","endRow","endCol","updatedNodes","CreateBorderWall","RecursiveDivisionUtil","height","width","orientation","randomCol","Math","floor","random","gapNodeRow","randomRow","gapNodeCol","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","Main","getInitialState","initialState","node","createNode","state","isMousePressed","isStartPressed","setState","console","log","parentNode","getNewGridWithToggled","map","rowIndex","nodeIndex","onClick","onClickNode","type","document","getElementById","value","visitedNodesAndPath","queue","parents","length","shift","i","unshift","getPathNodes","BfsAlgorithm","time_end","setTimeout","window","alert","randomMazeValues","wallsPlanted","RandomMaze","outputParameters","clearBoard","visualizeAlgorithm","createMaze","RecursiveDivisionMaze","renderGrid","slice","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4e359927.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.25bf045c.svg\";","import React from 'react';\r\nimport './Node.css';\r\n\r\nexport default class Node extends React.Component{\r\n    render(){\r\n        const {\r\n            key,\r\n            col,\r\n            row,\r\n            isStart,\r\n            isFinish,\r\n            isVisited,\r\n            isWall,      \r\n            isPath,\r\n        } = this.props;\r\n\r\n        let extendedClassName = \"\";\r\n\r\n        if(isStart){\r\n            extendedClassName = \"-isStart\";\r\n        }else if (isFinish){\r\n            extendedClassName = \"-isFinish\";\r\n        }else if (isWall){\r\n            extendedClassName = \"-isWall\";\r\n        }else if (isPath){\r\n            extendedClassName = \"-isPath\";\r\n        }else if (isVisited){\r\n            extendedClassName = \"-isVisited\";\r\n        }else{\r\n            extendedClassName = \"\";\r\n        }\r\n\r\n        const className = \"Node\" + extendedClassName;\r\n        let target = \"\";\r\n        if(isFinish) target = \"🎯\";\r\n        return(\r\n            <div \r\n                id = {`node-${row}-${col}`}\r\n                className = {className}\r\n                // onClick = {() => this.props.onClick()}\r\n                onMouseDown = {() => this.props.onMouseDown(row, col)}\r\n                onMouseEnter = {() => this.props.onMouseEnter(row, col)}\r\n                onMouseLeave = {() => this.props.onMouseLeave(row, col)}\r\n                onMouseUp = {() => this.props.onMouseUp(row, col)}\r\n            >\r\n                {/* {target} */}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\r\n\r\nexport default function BfsAlgorithm(nodes, startNode, finishNode, TOTAL_ROWS, TOTAL_COLS){\r\n    const tempNodes = nodes;\r\n    const visitedNodes = [];\r\n    const queue = [];\r\n    queue.push(startNode);\r\n    let parents = [];\r\n    let row = startNode.row;\r\n    let col = startNode.col;\r\n    parents[startNode.key] = startNode.key;\r\n    let isPathFound = false;\r\n\r\n    console.log(finishNode.isWall);\r\n\r\n    while(queue.length !== 0){\r\n        let currentNode = queue.shift();\r\n\r\n        if(currentNode===finishNode){\r\n            isPathFound = true;\r\n            break;\r\n        }\r\n\r\n        let neighbourNodes = getNeighbourNodes(nodes, currentNode, TOTAL_ROWS, TOTAL_COLS);\r\n\r\n        for(let i=0; i<neighbourNodes.length; i++){\r\n            let row = neighbourNodes[i].row;\r\n            let col = neighbourNodes[i].col;\r\n\r\n\r\n            if(!nodes[row][col].isVisited && !nodes[row][col].isWall){\r\n                queue.push(nodes[row][col]);\r\n\r\n                parents[nodes[row][col].key] = currentNode.key;\r\n\r\n                nodes[row][col].isVisited = true;  \r\n                nodes[row][col].parentNode = currentNode;\r\n                visitedNodes.push(nodes[row][col]);\r\n            }\r\n        }\r\n    }\r\n    let pathNodes = [];\r\n    if(isPathFound){\r\n        pathNodes = getPathNodes(finishNode, startNode);\r\n    }\r\n    return [visitedNodes, pathNodes];\r\n}\r\n\r\nfunction getPathNodes(finishNode, startNode){\r\n    let pathNodes = [];\r\n    while(!(startNode.row === finishNode.row) || !(startNode.col === finishNode.col)){\r\n        // if(!finishNode.isFinish && !finishNode.isStart){\r\n        pathNodes.unshift(finishNode);\r\n        // }\r\n\r\n        finishNode = finishNode.parentNode;\r\n    }\r\n    return pathNodes;\r\n}\r\n\r\nfunction getNeighbourNodes(nodes, currentNode, TOTAL_ROWS, TOTAL_COLS){\r\n    let row = currentNode.row;\r\n    let col = currentNode.col;\r\n    let neighbourNodes = [];\r\n    //right\r\n    if(col<TOTAL_COLS-1){\r\n        neighbourNodes.push(nodes[row][col+1]);\r\n    }\r\n    //bottom\r\n    if(row<TOTAL_ROWS-1){\r\n        neighbourNodes.push(nodes[row+1][col]);\r\n    }\r\n    //left\r\n    if(col>0){\r\n        neighbourNodes.push(nodes[row][col-1]);\r\n    }   \r\n    //up\r\n    if(row>0) {\r\n        neighbourNodes.push(nodes[row-1][col]);\r\n    }\r\n    return neighbourNodes;\r\n}\r\n","import React from 'react';\r\n\r\n\r\nexport default function DfsAlgorithm(nodes, startNode, finishNode, TOTAL_ROWS, TOTAL_COLS){\r\n    const dest = finishNode;\r\n    let isPathFound = false;\r\n    let parentNode = startNode;\r\n    let pathNodes = [];\r\n    let visitedNodesAndIsPathFound = DfsUtil(nodes, startNode, finishNode, [], TOTAL_ROWS, TOTAL_COLS, isPathFound, pathNodes);\r\n    const visitedNodes = visitedNodesAndIsPathFound[0];\r\n    isPathFound = visitedNodesAndIsPathFound[1];\r\n\r\n    if(isPathFound){\r\n        pathNodes =visitedNodesAndIsPathFound[2];\r\n    }\r\n    return [visitedNodes, pathNodes];\r\n}\r\n\r\n\r\nfunction DfsUtil(nodes, startNode, finishNode, visitedNodes, TOTAL_ROWS, TOTAL_COLS, isPathFound, pathNodes){\r\n\r\n    if (startNode.row===finishNode.row && startNode.col===finishNode.col){\r\n        return [visitedNodes, true, pathNodes];\r\n    }\r\n\r\n    //top\r\n    if(startNode.row>0 && !isPathFound){\r\n        let currentNode = nodes[startNode.row-1][startNode.col];\r\n        if(!currentNode.isWall && !currentNode.isVisited){\r\n            pathNodes.push(currentNode);\r\n            currentNode.isVisited = true;\r\n            visitedNodes.push(currentNode);\r\n            let visitedNodesAndIsPathFound = DfsUtil(nodes, currentNode, finishNode, visitedNodes, TOTAL_ROWS, TOTAL_COLS, isPathFound, pathNodes);\r\n            visitedNodes = visitedNodesAndIsPathFound[0];\r\n            isPathFound = visitedNodesAndIsPathFound[1];\r\n            (isPathFound) ? pathNodes = visitedNodesAndIsPathFound[2] : pathNodes.pop();\r\n        }\r\n    }\r\n\r\n    //right\r\n    if(startNode.col<TOTAL_COLS-1 && !isPathFound){\r\n        let currentNode = nodes[startNode.row][startNode.col+1];\r\n        if(!currentNode.isWall && !currentNode.isVisited){\r\n            pathNodes.push(currentNode);\r\n            currentNode.isVisited = true;\r\n            visitedNodes.push(currentNode);\r\n            let visitedNodesAndIsPathFound = DfsUtil(nodes, currentNode, finishNode, visitedNodes, TOTAL_ROWS, TOTAL_COLS, isPathFound, pathNodes);\r\n            visitedNodes = visitedNodesAndIsPathFound[0];\r\n            isPathFound = visitedNodesAndIsPathFound[1];\r\n            (isPathFound) ? pathNodes = visitedNodesAndIsPathFound[2] : pathNodes.pop();\r\n        }\r\n    }\r\n\r\n    //bottom\r\n    if(startNode.row<TOTAL_ROWS-1 && !isPathFound){\r\n        let currentNode = nodes[startNode.row+1][startNode.col];\r\n        if(!currentNode.isWall && !currentNode.isVisited){\r\n            pathNodes.push(currentNode);\r\n            currentNode.isVisited = true;\r\n            visitedNodes.push(currentNode);\r\n            let visitedNodesAndIsPathFound = DfsUtil(nodes, currentNode, finishNode, visitedNodes, TOTAL_ROWS, TOTAL_COLS, isPathFound, pathNodes);\r\n            visitedNodes = visitedNodesAndIsPathFound[0];\r\n            isPathFound = visitedNodesAndIsPathFound[1];\r\n            (isPathFound) ? pathNodes = visitedNodesAndIsPathFound[2] : pathNodes.pop();\r\n        }\r\n    }\r\n\r\n    //left\r\n    if(startNode.col>0 && !isPathFound){\r\n        let currentNode = nodes[startNode.row][startNode.col-1];\r\n        if(!currentNode.isWall && !currentNode.isVisited){\r\n            pathNodes.push(currentNode);\r\n            currentNode.isVisited = true;\r\n            visitedNodes.push(currentNode);\r\n            let visitedNodesAndIsPathFound = DfsUtil(nodes, currentNode, finishNode, visitedNodes, TOTAL_ROWS, TOTAL_COLS, isPathFound, pathNodes);\r\n            visitedNodes = visitedNodesAndIsPathFound[0];\r\n            isPathFound = visitedNodesAndIsPathFound[1];\r\n            (isPathFound) ? pathNodes = visitedNodesAndIsPathFound[2] : pathNodes.pop();\r\n        }\r\n    }\r\n\r\n    return [visitedNodes, isPathFound, pathNodes];\r\n\r\n}","import React from 'react';\r\nimport CreateBorderWall from './CreateBorderWall.jsx';\r\n\r\nexport default function RecursiveDivision(parameters){\r\n    let nodes = parameters.nodes;\r\n    let startRow = parameters.startRow;\r\n    let startCol = parameters.startCol;\r\n    let endRow = parameters.endRow;\r\n    let endCol = parameters.endCol;\r\n    const TOTAL_ROWS = parameters.TOTAL_ROWS;\r\n    const TOTAL_COLS = parameters.TOTAL_COLS;\r\n\r\n    const width = endCol-startCol;\r\n    const height = endRow-startCol;\r\n    const orientation = \"vertical\";\r\n    \r\n    // To create a border wall for the grid (external function)\r\n    let updatedNodes = CreateBorderWall(nodes, TOTAL_ROWS, TOTAL_COLS);\r\n\r\n    startRow += 1;\r\n    startCol += 1;\r\n    endRow -= 1;\r\n    endCol -= 1;\r\n\r\n    updatedNodes = RecursiveDivisionUtil(updatedNodes, startRow, startCol, endRow, endCol);   \r\n    \r\n    let START_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n    let START_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n    let FINISH_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n    let FINISH_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n\r\n    // Find random start Node\r\n    while(updatedNodes[START_NODE_ROW][START_NODE_COL].isWall){\r\n        START_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n        START_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n    }\r\n    // Set random start Node\r\n    updatedNodes[START_NODE_ROW][START_NODE_COL].isStart = true;\r\n\r\n    // Find random finish Node\r\n    while(updatedNodes[FINISH_NODE_ROW][FINISH_NODE_COL].isWall || updatedNodes[FINISH_NODE_ROW][FINISH_NODE_COL].isStart){\r\n        FINISH_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n        FINISH_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n    }\r\n    // Set random finish Node\r\n    updatedNodes[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = true;\r\n\r\n    const outputParameters = {\r\n        updatedNodes,\r\n        START_NODE_ROW,\r\n        START_NODE_COL,\r\n        FINISH_NODE_ROW,\r\n        FINISH_NODE_COL        \r\n    };\r\n    \r\n    return outputParameters;\r\n}\r\n\r\n\r\nfunction RecursiveDivisionUtil(updatedNodes, startRow, startCol, endRow, endCol){\r\n    let height = endRow-startRow;\r\n    let width = endCol-startCol;\r\n\r\n    if(width<5 || height<5) return updatedNodes;\r\n\r\n    let orientation = null;\r\n\r\n    (width>height) ? orientation=\"vertical\" : orientation=\"horizontal\";\r\n\r\n    if(orientation === \"vertical\"){\r\n        //                Math.floor(Math.random() * ( max -    min       + 1)) +    min;\r\n        let randomCol = (Math.floor(Math.random() * (endCol-2 - startCol+2 )) + startCol+2)-2;\r\n\r\n        while(randomCol===1){\r\n            randomCol = (Math.floor(Math.random() * (endCol-2 - startCol+2 )) + startCol+2)-2;\r\n        }\r\n        \r\n        // Wall the whole col \r\n        for(let row=startRow; row<endRow; row++){\r\n            updatedNodes[row][randomCol].isWall = true;\r\n        }\r\n\r\n        // Leave a gap in the col\r\n        const gapNodeRow = Math.floor(Math.random() * ( endRow - startRow - 1)) +   startRow;\r\n        updatedNodes[gapNodeRow][randomCol].isWall = false;\r\n\r\n        // Left portion after vertical skew\r\n        updatedNodes = RecursiveDivisionUtil(updatedNodes, startRow, startCol, endRow, randomCol-1);\r\n\r\n        // Right portion after vertical skew\r\n        updatedNodes = RecursiveDivisionUtil(updatedNodes, startRow, randomCol+1, endRow, endCol)\r\n    }\r\n\r\n    if(orientation === \"horizontal\"){\r\n        //               Math.floor(Math.random() * (  max -    min   + 1)) +    min;\r\n        let randomRow = (Math.floor(Math.random() * (endRow-2 - startRow+2 )) + startRow+2)-2;\r\n\r\n        while(randomRow===1){\r\n            randomRow = (Math.floor(Math.random() * (endRow-2 - startRow+2 )) + startRow+2)-2;\r\n        }\r\n\r\n        // Wall the whole row\r\n        for(let col=startCol; col<endCol; col++){\r\n            updatedNodes[randomRow][col].isWall = true;\r\n        }\r\n\r\n        // Leave a gap in the row\r\n        const gapNodeCol = Math.floor(Math.random() * ( endCol - startCol - 1)) +   startCol;\r\n        updatedNodes[randomRow][gapNodeCol].isWall = false;\r\n\r\n        // Top portion after horizontal skew\r\n        updatedNodes = RecursiveDivisionUtil(updatedNodes, startRow, startCol, randomRow-1, endCol);\r\n\r\n        // Bottom portion after horizontal skew\r\n        updatedNodes = RecursiveDivisionUtil(updatedNodes, randomRow+1, startCol, endRow, endCol);\r\n    }\r\n\r\n    return updatedNodes;\r\n}","import React from 'react';\r\n\r\nexport default function CreateBorderWall(nodes, TOTAL_ROWS, TOTAL_COLS){\r\n    \r\n    // Set first & last row - wall\r\n    for(let col=0; col<TOTAL_COLS; col++){\r\n        // first row\r\n        nodes[0][col].isWall = true;\r\n        // last row\r\n        nodes[TOTAL_ROWS-1][col].isWall = true;\r\n    }\r\n\r\n    // Set first and last col - wall\r\n    for(let row=0; row<TOTAL_ROWS; row++){\r\n        // first col\r\n        nodes[row][0].isWall = true;\r\n        // last col\r\n        nodes[row][TOTAL_COLS-1].isWall = true;\r\n    }\r\n\r\n    return nodes;\r\n}","import React from 'react';\r\nimport './PathfindingVisualizer.css';\r\nimport Node from './Node.jsx';\r\nimport BfsAlgorithm from '../Algorithms/BfsAlgorithm.jsx';\r\nimport DfsAlgorithm from '../Algorithms/DfsAlgorithm.jsx';\r\nimport RandomMaze from '../mazeAlgorithms/RandomMaze.jsx';\r\nimport RecursiveDivision from '../mazeAlgorithms/RecursiveDivision';\r\n\r\nconst TOTAL_ROWS = 27;\r\nconst TOTAL_COLS = 61;\r\n\r\nexport default class Main extends React.Component{\r\n    constructor(props){\r\n        super(props)\r\n        this.state = {\r\n            START_NODE_ROW : 11,\r\n            START_NODE_COL : 17,\r\n            FINISH_NODE_ROW : 11,\r\n            FINISH_NODE_COL : 42,\r\n            nodes : this.getInitialState(),\r\n            isMousePressed : false,\r\n            isStartPressed : false\r\n        };\r\n    }\r\n\r\n    getInitialState = () => {\r\n        const initialState = [];\r\n        for (let row=0; row<TOTAL_ROWS; row++){\r\n            initialState.push([]);\r\n            for (let node=0; node<TOTAL_COLS; node++){\r\n                initialState[row].push(this.createNode(row, node));\r\n            }\r\n        }\r\n        return initialState;\r\n    };\r\n\r\n    clearBoard(){\r\n        const initialState = this.getInitialState();\r\n        this.setState({nodes : initialState});\r\n        console.log(this.state.nodes[0][0]);    \r\n    }\r\n\r\n    componentDidMount(){\r\n        this.setState({\r\n            // START_NODE_ROW : 11,\r\n            // START_NODE_COL : 17,\r\n            // FINISH_NODE_ROW : 11,\r\n            // FINISH_NODE_COL : 42,\r\n        });\r\n        let nodes = [];\r\n        for (let row=0; row<TOTAL_ROWS; row++){\r\n            nodes.push([]);\r\n            for (let col=0; col<TOTAL_COLS; col++){\r\n                nodes[row].push(this.createNode(row, col));\r\n            }\r\n        }\r\n        this.setState({\r\n            nodes : nodes,\r\n            isMousePressed : false\r\n        });\r\n    }\r\n\r\n    createNode(row, col){\r\n        const START_NODE_ROW = 11;\r\n        const START_NODE_COL = 17;\r\n        const FINISH_NODE_ROW = 11;\r\n        const FINISH_NODE_COL = 42;\r\n        return({\r\n            key : row*100+col,\r\n            col,\r\n            row,\r\n            // isStart : row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            // isFinish : row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\\\r\n            isStart : row===START_NODE_ROW && col===START_NODE_COL,\r\n            isFinish : row===FINISH_NODE_ROW && col===FINISH_NODE_COL,\r\n            isVisited : false,\r\n            isWall : false,\r\n            isPath : false,\r\n            parentNode : null\r\n        });\r\n    }\r\n\r\n    onClickNode(row, col){\r\n        console.log(\"onClick\");\r\n        if(this.state.nodes[row][col].isStart){\r\n            return;\r\n        }\r\n        let updatedNodes = this.state.nodes;\r\n        if(updatedNodes[row][col].isStart || updatedNodes[row][col.isFinish]){\r\n            return;\r\n        }\r\n        updatedNodes[row][col].isWall = !updatedNodes[row][col].isWall;\r\n        this.setState({nodes : updatedNodes});\r\n    }\r\n\r\n    onMouseDown(row, col){\r\n        let nodes = this.state.nodes;\r\n        if(this.state.START_NODE_ROW===row && this.state.START_NODE_COL===col){\r\n            nodes[row][col].isStart = false;\r\n            this.setState({\r\n                // START_NODE_ROW : row,\r\n                // START_NODE_COL : col,\r\n                nodes : nodes,\r\n                isMousePressed : true,\r\n                isStartPressed : true\r\n            });\r\n            return;\r\n        }\r\n\r\n        const updatedNodes = getNewGridWithToggled(nodes, row, col);\r\n        this.setState({\r\n            nodes : updatedNodes,\r\n            isMousePressed : true\r\n        });\r\n    }\r\n\r\n    onMouseEnter(row, col){\r\n        // console.log(\"mouse Enter\");\r\n        if(this.state.isStartPressed){\r\n            return;\r\n        }\r\n\r\n        if(this.state.isMousePressed){\r\n            const updatedNodes = getNewGridWithToggled(this.state.nodes, row, col);\r\n            this.setState({ nodes : updatedNodes });\r\n        }\r\n    }\r\n\r\n    onMouseLeave(row, col){\r\n        // console.log(\"mouse leave\");\r\n        return;\r\n        if(this.state.isStartPressed){\r\n            const updatedNodes = getNewGridStartChange(this.state.nodes, row, col);\r\n            this.setState({\r\n                nodes : updatedNodes,\r\n            });\r\n            return;\r\n        }\r\n    }\r\n\r\n    onMouseUp(row, col){\r\n        if(this.state.isStartPressed){\r\n            let nodes = this.state.nodes;\r\n            nodes[row][col].isStart = true;\r\n\r\n            this.setState({\r\n                START_NODE_ROW : row,\r\n                START_NODE_COL : col,\r\n                nodes : nodes,\r\n                isMousePressed : false,\r\n                isStartPressed : false\r\n            });\r\n        }\r\n        this.setState({isMousePressed : false});\r\n        // alert(\"mouse up, startpress : \" +  this.state.isStartPressed);\r\n    }\r\n\r\n    renderGrid(nodes){\r\n        return nodes.map((row, rowIndex) => {\r\n            return row.map((node, nodeIndex) => {\r\n                const {key, col, row, isStart, isFinish, isVisited, isWall, isPath} = node;\r\n                    return(\r\n                        <div>\r\n                            <Node \r\n                                key = {key}\r\n                                col = {col}\r\n                                row = {row}\r\n                                isStart = {isStart}\r\n                                isFinish = {isFinish}\r\n                                isVisited = {isVisited}\r\n                                isWall = {isWall}  \r\n                                isPath = {isPath} \r\n                                onClick = {() => this.onClickNode(row, col)}\r\n                                onMouseDown = {() => this.onMouseDown(row, col)}\r\n                                onMouseEnter = {() => this.onMouseEnter(row, col)} \r\n                                onMouseLeave = {() => this.onMouseLeave(row, col)} \r\n                                onMouseUp = {() => this.onMouseUp(row, col)}\r\n                                // onMouseOver = {() => this.onMouseOver(row, col)}                       \r\n                            >\r\n                                \r\n                            </Node>\r\n                            {(TOTAL_COLS-1===col) ? <div className=\"Clear\"/> : \"\"}\r\n                        </div>\r\n                    );\r\n            });\r\n        });\r\n    }\r\n\r\n    visualizeAlgorithm(nodes){\r\n        const type = document.getElementById('Select').value;\r\n        if(type === \"none\"){\r\n            window.alert(\"Select type of algorithm.\");\r\n            return;\r\n        }\r\n\r\n        const startNode = nodes[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const finishNode = nodes[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n        let visitedNodes = [];\r\n        let visitedNodesAndPath = [];\r\n        if(type===\"bfs\"){\r\n            visitedNodesAndPath = BfsAlgorithm(nodes, startNode, finishNode, TOTAL_ROWS, TOTAL_COLS);\r\n        }else{\r\n            visitedNodesAndPath = DfsAlgorithm(nodes, startNode, finishNode, TOTAL_ROWS, TOTAL_COLS);\r\n        }\r\n\r\n        visitedNodes = visitedNodesAndPath[0];\r\n        let time_end = 0;\r\n        for(let i=0; i<visitedNodes.length; i++){\r\n            let row = visitedNodes[i].row;\r\n            let col = visitedNodes[i].col;\r\n\r\n            setTimeout(() => {\r\n                if(!nodes[row][col].isStart && !nodes[row][col].isFinish){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"Node-isVisited\";\r\n                    // nodes[row][col].isVisited = true;\r\n                    // this.setState({nodes});\r\n                }\r\n            }, i*5);\r\n            time_end = i*5;\r\n        }\r\n\r\n        const pathNodes = visitedNodesAndPath[1];\r\n        for(let i=0; i<pathNodes.length; i++){\r\n            let row = pathNodes[i].row;\r\n            let col = pathNodes[i].col;\r\n\r\n            setTimeout(() => {\r\n                if(!nodes[row][col].isStart && !nodes[row][col].isFinish){\r\n                    document.getElementById(`node-${row}-${col}`).className = \"Node-isPath\";\r\n                    // nodes[row][col].isPath = true;\r\n                    // this.setState({nodes});\r\n                }\r\n            }, (i*25)+time_end);\r\n        }           \r\n    }\r\n\r\n    createMaze(nodes, TOTAL_ROWS, TOTAL_COLS){\r\n        const parameters = {\r\n            nodes : this.getInitialState(),\r\n            TOTAL_ROWS,\r\n            TOTAL_COLS,\r\n            START_NODE_ROW : this.state.START_NODE_ROW,\r\n            START_NODE_COL : this.state.START_NODE_COL,\r\n            FINISH_NODE_ROW : this.state.FINISH_NODE_ROW,\r\n            FINISH_NODE_COL : this.state.FINISH_NODE_COL\r\n        };\r\n\r\n        const randomMazeValues = RandomMaze(parameters);\r\n        this.setState({\r\n            nodes : randomMazeValues.nodes,\r\n            START_NODE_ROW : randomMazeValues.START_NODE_ROW,\r\n            START_NODE_COL : randomMazeValues.START_NODE_COL,\r\n            FINISH_NODE_ROW : randomMazeValues.FINISH_NODE_ROW,\r\n            FINISH_NODE_COL : randomMazeValues.FINISH_NODE_COL\r\n        });\r\n    }\r\n\r\n    RecursiveDivisionMaze(){\r\n        let nodes = this.state.nodes;\r\n\r\n        // Remove all the walls\r\n        for(let row=0; row<TOTAL_ROWS; row++){\r\n            for(let col=0; col<TOTAL_COLS; col++){\r\n                nodes[row][col].isWall = false;\r\n            }\r\n        }\r\n\r\n        nodes[this.state.START_NODE_ROW][this.state.START_NODE_COL].isStart = false;\r\n        nodes[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL].isFinish = false;\r\n\r\n        const parameters = {\r\n            nodes,\r\n            startRow : 0,\r\n            startCol : 0,\r\n            endRow : TOTAL_ROWS,\r\n            endCol : TOTAL_COLS,\r\n            TOTAL_ROWS,\r\n            TOTAL_COLS\r\n        };\r\n\r\n        const outputParameters = RecursiveDivision(parameters);\r\n        this.setState({\r\n            nodes : outputParameters.updatedNodes,\r\n            START_NODE_ROW : outputParameters.START_NODE_ROW,\r\n            START_NODE_COL : outputParameters.START_NODE_COL,\r\n            FINISH_NODE_ROW : outputParameters.FINISH_NODE_ROW,\r\n            FINISH_NODE_COL : outputParameters.FINISH_NODE_COL\r\n        });\r\n\r\n    }\r\n    \r\n    render(){\r\n        return(\r\n            <div>\r\n                <select className=\"Select\" id=\"Select\">\r\n                    <option value=\"none\">none</option>\r\n                    <option value=\"bfs\"> bfs </option>\r\n                    <option value=\"dfs\"> dfs </option>                                  \r\n                </select>\r\n                <button className=\"Clear\"\r\n                        onClick = {() => this.clearBoard()}\r\n                >\r\n                    Clear Walls</button>\r\n                <button \r\n                    className=\"VisualizeAlgorithmButton\"\r\n                    onClick = {() => this.visualizeAlgorithm(this.state.nodes)}\r\n                >\r\n                    VISUALIZE ALGORITHM\r\n                </button>\r\n\r\n                <button onClick={() => this.createMaze(this.state.nodes, TOTAL_ROWS, TOTAL_COLS)}\r\n                >\r\n                    random maze\r\n                </button>\r\n\r\n                <button onClick={() => this.RecursiveDivisionMaze()}\r\n                >\r\n                    Recursive Division Maze\r\n                </button>\r\n\r\n\r\n                <div className = \"Grid\">\r\n                    {this.renderGrid(this.state.nodes)}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst getNewGridStartChange = (nodes, row, col) => {\r\n    let updatedNodes = nodes;\r\n    updatedNodes[row][col].isStart = !nodes[row][col].isStart;\r\n    return updatedNodes;\r\n}\r\n\r\nconst getNewGridWithToggled = (nodes, row, col) => {\r\n    if(nodes[row][col].isStart || nodes[row][col].isFinish){\r\n        return nodes;\r\n    }\r\n    let updatedNodes = nodes.slice();\r\n    updatedNodes[row][col].isWall = !nodes[row][col].isWall;\r\n    return updatedNodes;\r\n};","import React from 'react';\r\n\r\nexport default function RandomMaze(parameters){\r\n    let nodes = parameters.nodes;\r\n    const TOTAL_ROWS = parameters.TOTAL_ROWS;\r\n    const TOTAL_COLS = parameters.TOTAL_COLS;\r\n    let wallsPlanted = 0;\r\n    let random = 0\r\n\r\n    //To set current isStart false\r\n    nodes[parameters.START_NODE_ROW][parameters.START_NODE_COL].isStart = false;\r\n    nodes[parameters.FINISH_NODE_ROW][parameters.FINISH_NODE_COL].isFinish = false;\r\n\r\n    // To generate new startNode\r\n    const START_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n    const START_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n\r\n    nodes[START_NODE_ROW][START_NODE_COL].isStart = true;\r\n\r\n    // To generate new finish node\r\n    const FINISH_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n    const FINISH_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n\r\n    // Change finishNode if it is same as startNode\r\n    while(nodes[FINISH_NODE_ROW][FINISH_NODE_COL].isStart){\r\n        FINISH_NODE_ROW = Math.floor((Math.random())*TOTAL_ROWS);\r\n        FINISH_NODE_COL = Math.floor((Math.random())*TOTAL_COLS);\r\n    }\r\n\r\n    nodes[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = true;\r\n\r\n    // Create walls at 300 nodes\r\n    while(wallsPlanted < 300){\r\n        // Generate random row value for wall\r\n        random = Math.random();\r\n        let row = Math.floor(random*TOTAL_ROWS);\r\n\r\n        // Generate random col value for wall\r\n        random = Math.random();\r\n        let col = Math.floor(random*TOTAL_COLS);\r\n\r\n        // If the wall node is already occupied, then skip\r\n        if(nodes[row][col].isStart || nodes[row][col].isFinish || nodes[row][col].isWall){\r\n            continue;\r\n        }\r\n\r\n        nodes[row][col].isWall = true;\r\n        wallsPlanted ++;\r\n    }\r\n\r\n    // New node values generated by this function\r\n    const randomMazeValues = {\r\n        nodes,\r\n        START_NODE_ROW,\r\n        START_NODE_COL,\r\n        FINISH_NODE_ROW,\r\n        FINISH_NODE_COL\r\n    };\r\n\r\n    return randomMazeValues;\r\n}","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer.jsx';\n\nfunction App() {\n  return (\n    <PathfindingVisualizer/>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}